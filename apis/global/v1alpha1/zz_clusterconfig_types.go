/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ClusterConfigObservation struct {

	// The name of the Global Cluster.
	ClusterName *string `json:"clusterName,omitempty" tf:"cluster_name,omitempty"`

	// A map of all custom zone mappings defined for the Global Cluster. Atlas automatically maps each location code to the closest geographical zone. Custom zone mappings allow administrators to override these automatic mappings. If your Global Cluster does not have any custom zone mappings, this document is empty.
	CustomZoneMapping map[string]*string `json:"customZoneMapping,omitempty" tf:"custom_zone_mapping,omitempty"`

	// Each element in the list maps one ISO location code to a zone in your Global Cluster. See Custom Zone Mapping below for more details.
	CustomZoneMappings []CustomZoneMappingsObservation `json:"customZoneMappings,omitempty" tf:"custom_zone_mappings,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Add a managed namespaces to a Global Cluster. For more information about managed namespaces, see Global Clusters. See Managed Namespace below for more details.
	ManagedNamespaces []ManagedNamespacesObservation `json:"managedNamespaces,omitempty" tf:"managed_namespaces,omitempty"`

	// The unique ID for the project to create the database user.
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`
}

type ClusterConfigParameters struct {

	// The name of the Global Cluster.
	// +kubebuilder:validation:Optional
	ClusterName *string `json:"clusterName,omitempty" tf:"cluster_name,omitempty"`

	// Each element in the list maps one ISO location code to a zone in your Global Cluster. See Custom Zone Mapping below for more details.
	// +kubebuilder:validation:Optional
	CustomZoneMappings []CustomZoneMappingsParameters `json:"customZoneMappings,omitempty" tf:"custom_zone_mappings,omitempty"`

	// Add a managed namespaces to a Global Cluster. For more information about managed namespaces, see Global Clusters. See Managed Namespace below for more details.
	// +kubebuilder:validation:Optional
	ManagedNamespaces []ManagedNamespacesParameters `json:"managedNamespaces,omitempty" tf:"managed_namespaces,omitempty"`

	// The unique ID for the project to create the database user.
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`
}

type CustomZoneMappingsObservation struct {

	// The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes here.
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// The name of the zone in your Global Cluster that you want to map to location.
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type CustomZoneMappingsParameters struct {

	// The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes here.
	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// The name of the zone in your Global Cluster that you want to map to location.
	// +kubebuilder:validation:Optional
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type ManagedNamespacesObservation struct {

	// The name of the collection associated with the managed namespace.
	Collection *string `json:"collection,omitempty" tf:"collection,omitempty"`

	// The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
	CustomShardKey *string `json:"customShardKey,omitempty" tf:"custom_shard_key,omitempty"`

	// The name of the database containing the collection.
	DB *string `json:"db,omitempty" tf:"db,omitempty"`

	// Specifies whether the custom shard key for the collection is hashed. If omitted, defaults to false. If false, Atlas uses ranged sharding. This is only available for Atlas clusters with MongoDB v4.4 and later.
	IsCustomShardKeyHashed *bool `json:"isCustomShardKeyHashed,omitempty" tf:"is_custom_shard_key_hashed,omitempty"`

	// Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using hashed shard keys.
	IsShardKeyUnique *bool `json:"isShardKeyUnique,omitempty" tf:"is_shard_key_unique,omitempty"`
}

type ManagedNamespacesParameters struct {

	// The name of the collection associated with the managed namespace.
	// +kubebuilder:validation:Required
	Collection *string `json:"collection" tf:"collection,omitempty"`

	// The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
	// +kubebuilder:validation:Required
	CustomShardKey *string `json:"customShardKey" tf:"custom_shard_key,omitempty"`

	// The name of the database containing the collection.
	// +kubebuilder:validation:Required
	DB *string `json:"db" tf:"db,omitempty"`

	// Specifies whether the custom shard key for the collection is hashed. If omitted, defaults to false. If false, Atlas uses ranged sharding. This is only available for Atlas clusters with MongoDB v4.4 and later.
	// +kubebuilder:validation:Optional
	IsCustomShardKeyHashed *bool `json:"isCustomShardKeyHashed,omitempty" tf:"is_custom_shard_key_hashed,omitempty"`

	// Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using hashed shard keys.
	// +kubebuilder:validation:Optional
	IsShardKeyUnique *bool `json:"isShardKeyUnique,omitempty" tf:"is_shard_key_unique,omitempty"`
}

// ClusterConfigSpec defines the desired state of ClusterConfig
type ClusterConfigSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClusterConfigParameters `json:"forProvider"`
}

// ClusterConfigStatus defines the observed state of ClusterConfig.
type ClusterConfigStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClusterConfigObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterConfig is the Schema for the ClusterConfigs API. Provides a Global Cluster Configuration resource.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,mongodbatlas}
type ClusterConfig struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.clusterName)",message="clusterName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.projectId)",message="projectId is a required parameter"
	Spec   ClusterConfigSpec   `json:"spec"`
	Status ClusterConfigStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterConfigList contains a list of ClusterConfigs
type ClusterConfigList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ClusterConfig `json:"items"`
}

// Repository type metadata.
var (
	ClusterConfig_Kind             = "ClusterConfig"
	ClusterConfig_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ClusterConfig_Kind}.String()
	ClusterConfig_KindAPIVersion   = ClusterConfig_Kind + "." + CRDGroupVersion.String()
	ClusterConfig_GroupVersionKind = CRDGroupVersion.WithKind(ClusterConfig_Kind)
)

func init() {
	SchemeBuilder.Register(&ClusterConfig{}, &ClusterConfigList{})
}
