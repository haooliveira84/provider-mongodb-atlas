/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type EndpointObservation struct {

	// GCP network endpoint groups corresponding to the Private Service Connect endpoint service.
	EndpointGroupNames []*string `json:"endpointGroupNames,omitempty" tf:"endpoint_group_names,omitempty"`

	// Name of the PrivateLink endpoint service in AWS. Returns null while the endpoint service is being created.
	EndpointServiceName *string `json:"endpointServiceName,omitempty" tf:"endpoint_service_name,omitempty"`

	// Error message pertaining to the AWS PrivateLink connection. Returns null if there are no errors.
	// AWS:
	ErrorMessage *string `json:"errorMessage,omitempty" tf:"error_message,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Unique identifiers of the interface endpoints in your VPC that you added to the AWS PrivateLink connection.
	// AZURE:
	InterfaceEndpoints []*string `json:"interfaceEndpoints,omitempty" tf:"interface_endpoints,omitempty"`

	// All private endpoints that you have added to this Azure Private Link Service.
	PrivateEndpoints []*string `json:"privateEndpoints,omitempty" tf:"private_endpoints,omitempty"`

	// Unique identifier of the AWS PrivateLink connection.
	PrivateLinkID *string `json:"privateLinkId,omitempty" tf:"private_link_id,omitempty"`

	// Name of the Azure Private Link Service that Atlas manages.
	// GCP:
	PrivateLinkServiceName *string `json:"privateLinkServiceName,omitempty" tf:"private_link_service_name,omitempty"`

	PrivateLinkServiceResourceID *string `json:"privateLinkServiceResourceId,omitempty" tf:"private_link_service_resource_id,omitempty"`

	// Required 	Unique identifier for the project.
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// Name of the cloud provider for which you want to create the private endpoint service. Atlas accepts AWS, AZURE or GCP.
	ProviderName *string `json:"providerName,omitempty" tf:"provider_name,omitempty"`

	// Cloud provider region in which you want to create the private endpoint connection.
	// Accepted values are: AWS regions, AZURE regions and GCP regions
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// GCP region for the Private Service Connect endpoint service.
	RegionName *string `json:"regionName,omitempty" tf:"region_name,omitempty"`

	// Unique alphanumeric and special character strings that identify the service attachments associated with the GCP Private Service Connect endpoint service. Returns an empty list while Atlas creates the service attachments.
	ServiceAttachmentNames []*string `json:"serviceAttachmentNames,omitempty" tf:"service_attachment_names,omitempty"`

	// Status of the AWS PrivateLink connection or Status of the Azure Private Link Service. Atlas returns one of the following values:
	// AWS:
	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type EndpointParameters struct {

	// Required 	Unique identifier for the project.
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// Name of the cloud provider for which you want to create the private endpoint service. Atlas accepts AWS, AZURE or GCP.
	// +kubebuilder:validation:Optional
	ProviderName *string `json:"providerName,omitempty" tf:"provider_name,omitempty"`

	// Cloud provider region in which you want to create the private endpoint connection.
	// Accepted values are: AWS regions, AZURE regions and GCP regions
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

// EndpointSpec defines the desired state of Endpoint
type EndpointSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     EndpointParameters `json:"forProvider"`
}

// EndpointStatus defines the observed state of Endpoint.
type EndpointStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        EndpointObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Endpoint is the Schema for the Endpoints API. Provides a Private Endpoint resource.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,mongodbatlas}
type Endpoint struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.projectId)",message="projectId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.providerName)",message="providerName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.region)",message="region is a required parameter"
	Spec   EndpointSpec   `json:"spec"`
	Status EndpointStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// EndpointList contains a list of Endpoints
type EndpointList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Endpoint `json:"items"`
}

// Repository type metadata.
var (
	Endpoint_Kind             = "Endpoint"
	Endpoint_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Endpoint_Kind}.String()
	Endpoint_KindAPIVersion   = Endpoint_Kind + "." + CRDGroupVersion.String()
	Endpoint_GroupVersionKind = CRDGroupVersion.WithKind(Endpoint_Kind)
)

func init() {
	SchemeBuilder.Register(&Endpoint{}, &EndpointList{})
}
